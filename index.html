<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<div>
						Type-safe state management made easy
						<p>(with React and TypeScript)</p>
						<p style="font-size:25px;">Featuring Our Special Guest: GraphQL</p>
						<div style="font-size: 25px; margin-top: 75px; font-style: italic;">
							<p>Lily Barrett</p>
							<p>Software Engineer @EF/Go Ahead Tours</p>
							<p>Girl Develop It Boston Leadership Team</p>
						</div>
					</div>
				</section>
				<section>
					<div>
						<h2>Why not just use <a href="https://redux.js.org/">Redux?</a></h3>
					</div>
				</section>
				<section>
					<div style="float: left; width: 75%;">
						<ul>
							<li>Redux could be overly complex for your application</li>
							<li>You may not want or need to use the entire Redux ecosystem</li>
							<li>It’s got tons of boilerplate code</li>
							<li>It can be a pain to set up Redux with TypeScript</li>
						</ul>
					</div>
					<div style="float: right; width: 25%; height: 300px;">
						<img src= "https://cdn-images-1.medium.com/max/600/0*U2DmhXYumRyXH6X1.png"/>
					</div>
				</section>
				<section>
					<h3>
						React’s <a href="https://reactjs.org/docs/context.html">Context API</a>
					</h3>
				</section>
				<section>
					<div style="float: left; width: 45%; font-size: 30px; margin-right: 15px;">
						<ul>
							<li>
								“An upgraded version of old concept of context in React which allow[s] components to share data outside the parent-child relationship.”
								<span style="font-size: 20px;">~ Rakshit Soral, “Everything You Need to Know About React’s Context API”</span>
							</li>
							<li>
								Tl;dr: A way to share state & avoid prop drilling (as of React 16.3)
							</li>
						</ul>
					</div>
					<div style="float: right; width: 50%; height: 300px;">
						<img src= "https://www.carlrippon.com/wp-content/uploads/2018/04/prop-drilling-v-context.png"/>
						<span style="font-size: 10px;">
							https://www.carlrippon.com/playing-with-the-context-api-in-react-16-3/
						</span>
					</div>
				</section>
				<section>
					<div style="float: left; width: 45%; font-size: 25px;">
						<ul>
							<li style="margin-top: 30px;">
								React.createContext(): Creates the Context and passes it an initial value. Returns an object with a Provider and a Consumer.
							</li>
							<li style="margin-top: 30px;">
								Provider: Accepts a "value" prop
							</li>
							<li style="margin-top: 30px;">
								Consumer: Accepts a "children" prop, which should be a function that accepts the value from the Provider and returns JSX
							</li>
						</ul>
					</div>
					<div style="float: right; width: 50%; height: 500px;">
						<img src="./images/context-api-diagram.png" />
					</div>
				</section>
				<section>
					<p>The best way to explain the Context API in action is to show you. Stay tuned for our demo...</p>
				</section>
				<section>
					<h3>
						But first, <a href="https://graphql.org/">GraphQL</a>
					</h3>
				</section>
				<section>
					<div>
						<ul>
							<li>
								A query language that allows you to request only the data you want, when you want it
							</li>
							<li>
								Unlike REST, uses ONE single endpoint to allow you to fetch data via multiple queries at once
							</li>
							<li>
								Built-in type system that helps provide dynamic API self-documentation
							</li>
							<li>
								We can generate static types for our queries with the <a href="https://github.com/apollographql/apollo-cli">apollo-cli</a>
							</li>
						</ul>
					</div>
					<div>
						<img src="./images/graphql.png" />
						<span style="font-size: 10px;">
							https://graphql.org/
						</span>
					</div>
				</section>
				<section>
					<h5>Adding GraphQL to your app</h5>
					<div data-markdown>
						```
						$ npm install --save apollo-boost react-apollo graphql
						```
					</div>
					<div>
						<p style="font-size: 25px; font-weight: bold;">
							apollo-boost bundles up several handy packages for working w/ Apollo Client, including:
						</p>
						<ul style="font-size: 25px;">
							<li>
								<span style="font-weight: bold;">apollo-client:</span> A caching GraphQL client made for use with React, Angular, etc.
							</li>
							<li>
								<span style="font-weight: bold;">apollo-cache-inmemory: </span> The standard, in-memory cache recommended by Apollo Client
							</li>
							<li>
								<span style="font-weight: bold;">apollo-link-http: </span>Fetches GraphQL results from a GraphQL endpoint over an http connection
							</li>
							<li>
								<span style="font-weight: bold;">graphql-tag: </span>Exports the gql function, allowing us to write easily parseable strings for our queries and mutations
							</li>
							<li>
								<span style="font-weight: bold;">react-apollo: </span>Contains bindings to use Apollo Client with React
							</li>
							<li>
								<span style="font-weight: bold;">graphql: </span>References Facebook's original implementation of GraphQL
							</li>
						</ul>
					</div>
				</section>
				<section>
					<h5>Configuring the client</h5>
					<p>From the <a href="https://github.com/apollographql/react-apollo">React Apollo docs</a></p>
					<div data-markdown>
						```
						import { ApolloClient } from 'apollo-client';
						import { HttpLink } from 'apollo-link-http';
						import { InMemoryCache } from 'apollo-cache-inmemory';

						const client = new ApolloClient({
							// By default, this client will send queries to the
							//  `/graphql` endpoint on the same host
							// Pass the configuration option { uri: YOUR_GRAPHQL_API_URL } to the `HttpLink` to connect
							// to a different host
							link: new HttpLink(),
							cache: new InMemoryCache(),
						});
						```
					</div>
				</section>
				<section>
					<h5>Wrapping your root component in an Apollo Provider</h5>
					<p>This provides you to implicitly connect each component in your tree to GraphQL via Apollo</p>
					<p>Also from the <a href="https://github.com/apollographql/react-apollo">React Apollo docs</a></p>
					<pre><code data-trim data-noescape>
					import { ApolloProvider } from 'react-apollo';

					ReactDOM.render(
						&lt;ApolloProvider client={client}&gt;
							&lt;MyRootComponent&gt;
						&lt;ApolloProvider&gt;,
						document.getElementById('root'),
					);
					</code></pre>
				</section>
				<section>
					<h5>Generating types with Apollo</h5>
					<div data-markdown>
						```
						$ npm i --save apollo-codegen
						```
					</div>
					<div>
						In your package.json, I recommend adding the following scripts:
						<div data-markdown>
							```
							"introspect": "apollo-codegen introspect-schema GRAPHQL_ENDPOINT --output PATH_TO_SCHEMA_FILE",
							// this fetches the schema and saves it in our project
							"generate": "apollo-codegen generate GLOB_PATH_TO_QUERY_FILES --schema PATH_TO_SCHEMA_FILE --target typescript --output PATH_TO_GENERATED_TYPES_FILE --add-typename --tag-name gql",
							// this generates type interfaces from our schema
							"typegen": "npm run introspect && npm run generate",
							```
						</div>
						And, once your queries are in place, run:
						<div data-markdown>
							```
							$ npm run typegen
							```
						</div>
					</div>
				</section>
				<section>
					<h3>Demo time!</h3>
				</section>
				<section>
					<p>In a burst of hubris the other day, I decided to build the next Amazon.</p>
				</section>
				<section>
					<p>Thankfully, I decided to start small.</p>
				</section>
				<section>
					<h3>Welcome to my Jawn!</h3>
					<p style="font-size: 20px;">Jawn: <span style="font-style: italic;">noun</span>, chiefly in eastern Pennsylvania, used to refer to a thing, place, person, or event that one need not or cannot give a specific name to.</p>
				</section>
				<section>
					<img src="./images/jawn-shot.png" />
				</section>
				<section>
					<h3>Lily's Jawn:</h3>
					<ul>
						<li>Uses TypeScript with Parcel.js, which supports TS right out of the box</li>
						<li>Calls a <a href="https://github.com/notrab/fakerql">FakerQL</a> endpoint to emulate GraphQL queries, mutations, etc.</li>
						<li>Uses the Context API!</li>
					</ul>
					<p>Let's break it all down.</p>
				</section>
				<section style="text-align: left;">
					<p>FakerQL, given to us by <a href="https://github.com/marak/Faker.js/">faker.js</a>, offers us the following types to query:</p>
					<ul>
						<li>
							Post
						</li>
						<li>
							Product
						</li>
						<li>
							User
						</li>
						<li>
							Todo
						</li>
					</ul>
					<p>For our purposes, we'll be querying Products for our store.</p>
				</section>
				<section>
					<h3>
						Let's set up our GraphQL client!
					</h3>
				</section>
				<section>
					<p>My app already has all the necessary Apollo Client dependencies installed, and these scripts in my package.json:</p>
					<div data-markdown>
						```
						"scripts": {
							"test": "npm run test",
							"dev": "parcel ./index.html",
							"introspect": "apollo-codegen introspect-schema https://fakerql.com/graphql --output ./data/models/index.json",
							"generate": "apollo-codegen generate ./data/**/*.ts --schema ./data/models/index.json --target typescript --output ./data/models/index.ts --add-typename --tag-name gql",
							"typegen": "npm run introspect && npm run generate",
							"build": "tsc"
						},
						```
					</div>
				</section>
				<section>
					<p>With these scripts, we'll be generating a schema and types from my data folder, which is structured like this:</p>
					<div data-markdown>
						```
						- data
							- formatters
								// for formatting/calculating item prices in USD vs. Euros (More on this later!)
							- models
								// when I run my "introspect" script, Apollo will reference the FakerQL endpoint and output the schema onto an index.json file
								// all files in this folder are auto-generated by the script
							- queries
								// where my GraphQL queries live
								// when I run my "generate" script, Apollo will look at my queries, in combination with the endpoint schema, and output types onto an index.ts file in my models folder
						```
					</div>
				</section>
				<section>
					<p>We need to create an instance of Apollo Client so we can take advantage of it.</p>
					<pre><code data-trim data-noescape>
					// ./index.tsx
					import React from "react";
					import { ApolloProvider } from "react-apollo";
					import { ApolloClient } from "apollo-client";
					import { HttpLink } from "apollo-link-http";
					import { InMemoryCache } from "apollo-cache-inmemory";

					const client = new ApolloClient({
						link: new HttpLink({
							uri: "https://fakerql.com/graphql",
							// Remember, we only need ONE endpoint!
						}),
						cache: new InMemoryCache(),
					});

					class App extends React.Component {
						public render () {
							&lt;ApolloProvider client={client}&gt;
								// App contents
							&lt;ApolloProvider&gt;
						}
					}
					</code></pre>
				</section>
				<section style="text-align: left;">
					<p>Let's get down to business. I need a query to fetch all the products via FakerQL.</p>
					<p>I recommend having a file for each query in your data folder.</p>
					<div data-markdown>
						```
						// data/queries/JAWN_QUERY.ts
						import gql from "graphql-tag";
						export default gql`
							query FindJawnProducts {
								// The FakerQL docs tell me I can query "allProducts" and get a list of products back
								// I'm also specifying the fields I want returned for each Product: id, name, price
								allProducts {
									id
									name
									price
								}
							}
						`;
						```
					</div>
				</section>
				<section>
					<p>When I run "npm run typegen", here are the types that get generated:</p>
					<div data-markdown>
					```
					export interface FindJawnProducts_allProducts {
						__typename: "Product";
						id: string;
						name: string;
						price: string;
					}

					export interface FindJawnProducts {
						allProducts: (FindJawnProducts_allProducts | null)[] | null;
					}
					```
					</div>
					<p>These will be useful for setting up our context and typing our components!</p>
				</section>
				<section style="text-align: left;">
					<div style="font-size: 25px;">
						<p>Before we hook our components up to GraphQL: What other information do we want besides data about Products, fetched from FakerQL?</p>
						<p>Hmm. Well, we want to support two different markets: The U.S. and Europe. In order to provide the correct calculations for product prices, we need our components to be aware of our market.</p>
						<p>It probably makes sense to define our market via our root component:</p>
					</div>
					<pre><code data-trim data-noescape>
					class App extends React.Component {
						public render () {
					    	const { market } = this.props;
						return (
					        	&lt;ApolloProvider client={client}&gt;
						    		&lt;&gt;
							    	  &lt;JawnList /&gt;
								  	// Will display list of all products from the API
							      	  &lt;Cart /&gt;
								  	// Will display all the products we've picked off the list and put in our shopping cart
								&lt;&gt;
						  	&lt;/ApolloProvider&gt;
					     	);
					   	}
				    }

					const HotApp = hot(module)(App);

					render(&lt;HotApp market="US"/&gt;, document.getElementById("root"));
					</code></pre>
				</section>
				<section style="text-align: left; font-size: 25px;">
					<p>But we don't want to drill props down from the root component just to provide awareness about our market.</p>
					<p>We also have two components -- JawnList and Cart -- that potentially need to know about the products we're fetching from our API, but we don't want to pass that data down as a prop, either.<p>
					</p>Reason being: Our MVP <span style="font-style: italic;">could</span> grow into a much bigger app, and we don't want to wind up passing details down through components that don't care about them.</p>
					<p>Enter the Context API!</p>
				</section>
				<section>
					<h3>
						Let's set up our context!
					</h3>
				</section>
				<section>
					<p>I create a file called JawnContext.tsx, where I define and create my context for the application:</p>
					<div data-markdown>
					```
					import React from "react";
					import { FindJawnProducts, FindJawnProducts_allProducts } from "./data/models";

					export interface JawnState {
						cart?: FindJawnProducts_allProducts[];
						// One of our Apollo-generated types!
						addToCart?: (product: FindJawnProducts_allProducts) => void;
						// Anther one of our Apollo-generated types!
						removeFromCart?: (index: number) => void;
						market?: "US" | "UK";
					}

					export default React.createContext<JawnState>(null);
					// Where the magic happens
					// `null` here is our default value for the context
					```
					</div>
				</section>
				<section>
					<p>Next, let's hook up our context to our root component.</p>
					<pre><code data-trim data-noescape>
					class App extends React.Component<JawnState> {
						public render () {
							const { market } = this.props;
							return (
								<ApolloProvider client={client}>
									<JawnContext.Provider value={{
										cart: this.state.cart,
										addToCart: this.addToCart,
										removeFromCart: this.removeFromCart,
										market,
									}}>
										<Container fluid>
											<Row>
												<Col xs={12} sm={6}>
													<JawnList />
												</Col>
												<Col xs={12} sm={6}>
													<Cart />
												</Col>
											</Row>
										</Container>
									</JawnContext.Provider>
								</ApolloProvider>
							);
						}
					}
					</code></pre>
				</section>
				<section>
					<p>Let's make it easy for our components to quickly and composably consume the context by creating a provider:</p>
					<pre>
						<code data-trim data-noescape>
						import React from "react";
						import JawnContext, { JawnState } from "./JawnContext";

						export default function WithJawnContext<Props extends JawnState> (Child: React.ComponentType<Props>) {
								return (props: Props) => (
									<JawnContext.Consumer>
										{(contextState) => (
											<Child {...props} {...contextState} />
										)}
									</JawnContext.Consumer>
								);
						}
						</code>
					</pre>
				</section>
				<section>
					<p>Let's allow JawnList to "consume" our context!</p>
					<pre><code data-trim data-noescape>
					import React from "react";
					import { JAWN_QUERY } from "../data/queries";
					import { graphql, ChildDataProps } from "react-apollo";
					import { FindJawnProducts } from "../data/models";
					import WithJawnContext from "../WithJawnContext";
					import { JawnState } from "../JawnContext";
					import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
					import { faPlus } from "@fortawesome/fontawesome-free-solid";
					import styled from "react-emotion";
					import { formatMoney } from "../data/formatters";

					type JawnListType = ChildDataProps<{}, FindJawnProducts> & JawnState;

					const IconWrapper = styled("span")`
						margin-left: 5px;
					`;

					const JawnList: React.SFC<JawnListType> = ({ data, market, addToCart }) => {
						if (data.loading) {
							return <div>Loading incredibly important and valuable inventory...</div>;
						}
						return (
							<>
								<h1>Welcome to Lily's Jawn</h1>
								<ul>
									{
										data.allProducts.map((product) => {
											const { id, price, name } = product;
											const formattedPrice = formatMoney(market, price);
											return (
												<li key={id}>
													{name} - {formattedPrice}
													<IconWrapper onClick={() => addToCart(product)}>
														<FontAwesomeIcon
															icon={faPlus}
														/>
													</IconWrapper>
												</li>
											);
										})
									}
								</ul>
							</>
						);
					};

					const WithJawnProductData = graphql<{}, FindJawnProducts>(JAWN_QUERY);

					export default WithJawnProductData(WithJawnContext(JawnList));
					</code></pre>
				</section>
				<section>
					<p>Let's also allow Cart to consume the context</p>
					<pre><code data-trim data-noescape>
					import React, { Component } from "react";
					import { JawnState } from "../JawnContext";
					import WithJawnContext from "../WithJawnContext";
					import { formatMoney } from "../data/formatters";
					import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
					import { faMinus } from "@fortawesome/fontawesome-free-solid";
					import styled from "react-emotion";

					const IconWrapper = styled("span")`
						margin-left: 5px;
					`;

					const Cart: React.SFC<JawnState> = ({ market, cart, removeFromCart }) => {
						const total = cart.reduce((sum, item) => {
							sum += parseInt(item.price, 10);
							return sum;
						}, 0);
						return (
							<>
									<h1>Your cart</h1>
									<ul>
										{ cart.map((item, index) => (
											<li key={index}>
												{item.name} - {formatMoney(market, item.price)}
												<IconWrapper onClick={() => removeFromCart(index)}>
													<FontAwesomeIcon icon={faMinus} />
												</IconWrapper>
											</li>
										))}
									</ul>
									<h3>
										Total: ${total}
									</h3>
								</>
						);
					};

					export default WithJawnContext(Cart);
					</code></pre>
				</section>
				<section>
					<p>Takeaways</p>
					<ul>
						<li>The Context API, in conjunction with TypeScript, provides a type-safe, lightweight way to share state and data without drilling props down</li>
						<li>Apollo allows us to use TypeScript to generate query and schema types for our GraphQL queries and mutations</li>
						<li>Voila! Type-safe state management!</li>
					</ul>
				</section>
				<section>
					Questions?
					(provide github, blog, linkedin, email)
				</section>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
